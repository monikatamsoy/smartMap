<!DOCTYPE html>
<html>
    <head>
        <title>Planets and moons</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    </head>
    <body>
        <div id="city"></div>

        <script src="js/OrbitControls.js"></script>
        <script type = "module" >
            import {LoadingBar} from "./libs/LoadingBar.js";
        </script>
        
        <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
        <script type='module' >
            var scene, camera, controls, renderer, city, pin;

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function onMouseMove( event ) {

                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                console.log(mouse.x, mouse.y);

            }   

            function update(renderer, scene, camera, controls) {
                
                controls.update();    
                
                raycaster.setFromCamera( mouse, camera );

                // calculate objects intersecting the picking ray
                const intersects = raycaster.intersectObjects( scene.children );

                for ( let i = 0; i < intersects.length; i ++ ) {

                    intersects[ i ].object.material.color.set( 0xff0000 );
                    // console.log(intersects[i].object.position)

                }

                renderer.render(scene, camera);

                // requestAnimationFrame(this.animate.bind(this));
                requestAnimationFrame(function () {
                    update(renderer, scene, camera, controls);
                });
}
            function init() {
                // Create the camera that allows us to view into the scene.
                camera = new THREE.PerspectiveCamera(
                    45, // field of view
                    window.innerWidth / window.innerHeight, // aspect ratio
                    0.1, // near clipping plane
                    10000 // far clipping plane
                );
                camera.position.z = 50;
                camera.position.x = 0;
                camera.position.y = 20;
                
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // Create the scene that holds all of the visible objects.
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Create the renderer that controls animation.
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Attach the renderer to the div element.
                
                // Create controls that allows a user to move the scene with a mouse.
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                
                
                var ambientLight = new THREE.AmbientLight(0xffffff);
                scene.add(ambientLight);

                const size = 50;
                const divisions = 50;

                const gridHelper = new THREE.GridHelper( size, divisions );
                scene.add( gridHelper );
                
                
                document.getElementById("city").appendChild(renderer.domElement);
                

                
                
                // var loadingBar = new THREE.LoadingBar();

                let loader = new THREE.GLTFLoader( );
                // loader.setPath('./img/');
                // loader.setPath('./img/');
                loader.load(
                    // resource URL
                    "./assets/desertCity.glb",
                    // called when the resource is loaded
                    function ( gltf ) {
                        const bbox = new THREE.Box3().setFromObject( gltf.scene );
                        console.log(`min:${bbox.min.x.toFixed(2)},${bbox.min.y.toFixed(2)},${bbox.min.z.toFixed(2)} -  max:${bbox.max.x.toFixed(2)},${bbox.max.y.toFixed(2)},${bbox.max.z.toFixed(2)}`);
                        
                        gltf.scene.traverse( ( child ) => {
                            if (child.isMesh){
                                child.material.metalness = 0.2;
                            }
                        })
                        
                        city = gltf.scene;
                        city.scale.set(0.2,0.2,0.2);
                        city.position.set(0,0,0);
                        

                        // city.rotation.x = Math.PI/2
                        scene.add( gltf.scene );
                        
                    },
                    // called while loading is progressing
                    function ( xhr ) {

                        // loadingBar.progress = (xhr.loaded / xhr.total);
                        
                    },
                    // called when loading has errors
                    function ( error ) {

                        console.log( 'An error happened' );

                    }  
                    
                );
                loader.load(
                    // resource URL
                    "./assets/pin.glb",
                    // called when the resource is loaded
                    function ( gltf ) {
                        const bbox = new THREE.Box3().setFromObject( gltf.scene );
                        console.log(`min:${bbox.min.x.toFixed(2)},${bbox.min.y.toFixed(2)},${bbox.min.z.toFixed(2)} -  max:${bbox.max.x.toFixed(2)},${bbox.max.y.toFixed(2)},${bbox.max.z.toFixed(2)}`);
                        
                        gltf.scene.traverse( ( child ) => {
                            if (child.isMesh){
                                child.material.metalness = 0.2;
                            }
                        })
                        
                        pin = gltf.scene;
                        pin.scale.set(1.5,1.5,1.5);
                        pin.position.set(40,6,0);
                        

                        // city.rotation.x = Math.PI/2
                        scene.add( gltf.scene );
                        
                    
                        
                        // loadingBar.visible = false;
                        // window.self = self;
                        // renderer.setAnimationLoop( self.render.bind(self));
                    },
                    // called while loading is progressing
                    function ( xhr ) {

                        // loadingBar.progress = (xhr.loaded / xhr.total);
                        
                    },
                    // called when loading has errors
                    function ( error ) {

                        console.log( 'An error happened' );

                    }  
                    
                );

                
               
                
                
                update(renderer, scene, camera, controls);

                window.addEventListener("resize", onWindowResize, false);
                window.addEventListener( 'mousemove', onMouseMove, false );
                


                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();

                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }
            init();
        </script>
        
    </body>
</html>
